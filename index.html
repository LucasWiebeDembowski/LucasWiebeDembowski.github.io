<!DOCTYPE HTML>
<html>
    <head>
        <title>Bouncy balls</title>
        <!-- https://developers.google.com/fonts/docs/material_symbols -->
        <!-- static -->
        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0&icon_names=pause,play_arrow" />
        <style>
            .button {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                padding: 8px 16px;
                gap: 8px;

                background-color: #166df7;
                border-radius: 5px;
                color: #ffffff;

                font-size: medium;
            }
            .pauseButtonTooltip .tooltiptext {
                /* https://www.w3schools.com/css/css_tooltip.asp */
                visibility: hidden;
                width: 400px;
                background-color: grey;
                color: #fff;
                text-align: center;
                border-radius: 6px;
                padding: 5px 0;

                position: absolute;
                z-index: 1;
            }
            .pauseButtonTooltip:hover .tooltiptext {
                visibility: visible;
            }
        </style>
    </head>
    <body>
        <p>
            <div class="pauseButtonTooltip">
            <button id="btnPause" class="button" type="button" onclick="togglePaused()">
                <span id="pauseButtonName" class="material-symbols-outlined">pause</span>
                <span id="pauseButtonText"><u>P</u>ause</span>
            </button>
            <span class="tooltiptext">You can also press p to play or pause the game.</span>
            </div>
        </p>
        <canvas id="myCanvas" width="600" height="600" style="border: 1px solid #d3d3d3;">
            Your browser does not support HTML canvas tag :(
        </canvas>
        <script>
            const canvas = document.getElementById("myCanvas");
            const ctx = canvas.getContext("2d");
            const gravity = 2000; // pixels per second per second
            
            class Circle {
                constructor(x,y,vx,vy,radius) {
                    this.x = x;
                    this.y = y;
                    this.vx = vx;
                    this.vy = vy;
                    this.radius = radius;
                    this.vxCached = vx;
                    this.vyCached = vy;
                    this.ay = gravity;
                    this.ayCached = gravity;
                }
                pause() {
                    this.vxCached = this.vx;
                    this.vyCached = this.vy;
                    this.ayCached = this.ay;
                    this.vx = 0;
                    this.vy = 0;
                    this.ay = 0;
                }
                resume() {
                    this.vx = this.vxCached;
                    this.vy = this.vyCached;
                    this.ay = this.ayCached;
                }
                update(elapsedSec) {
                    this.x += elapsedSec * this.vx;
                    // prevent going off edge
                    if(this.x -this. radius < 0) {
                        this.x = this.radius;
                        this.vx = -this.vx;
                    }
                    if (this.x + this.radius > canvas.width) {
                        this.x = canvas.width - this.radius;
                        this.vx = -this.vx;
                    }

                    this.vy += this.ay * elapsedSec;
                    // Bounce off the ground.
                    if(this.vy > 0 && (this.y + elapsedSec * this.vy + this.radius > canvas.height)) {
                        // vy is only accelerating until it bounces, after which it is decelerating.
                        const distanceAboveGround = canvas.height - (this.y + this.radius);
                        let vground = Math.sqrt(this.vy*this.vy + 2*this.ay*distanceAboveGround);
                        let trise = elapsedSec - (vground - this.vy) / this.ay;
                        this.vy = -vground + this.ay*trise;
                        this.y = canvas.height - this.radius - (vground*trise - 0.5*this.ay*trise*trise);
                    }else {
                        // Falling normally
                        this.y += elapsedSec * this.vy;
                    }

                    // prevent going past the top
                    if(this.y - this.radius < 0) {
                        this.y = this.radius;
                        this.vy = -this.vy;
                    }
                }
                render() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI);
                    ctx.stroke();
                }
            }
            
            let paused = false;
            let objects = []
            objects.push(new Circle(0.5*canvas.width, 0.5*canvas.height, 100, 0, 40))
            objects.push(new Circle(0.25*canvas.width, 0.25*canvas.height, 100, 0, 60))
            function togglePaused() {
                paused = !paused;
                document.getElementById('pauseButtonName').innerHTML = paused ? "play_arrow" : "pause";
                document.getElementById('pauseButtonText').innerHTML = paused ? "<u>P</u>lay" : "<u>P</u>ause";
                if(paused) {
                    for(obj of objects) {
                        obj.pause();
                    }
                }else {
                    for(obj of objects) {
                        obj.resume();
                    }
                }
            }

            document.addEventListener('keyup', (event) => {
                switch(event.key) {
                    case 'p':
                        togglePaused();
                        break;
                    default: break;
                }
            });

            function render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for(obj of objects) {
                    obj.render();
                }
            }

            const msPerSec = 1000;

            function start() {
                requestAnimationFrame(update);
                thenMs = Date.now();
            }

            function update(timestampMs) {
                requestAnimationFrame(update);
                nowMs = Date.now();
                const frameTimeSecCap = 0.05; // arbitrary value, avoids huge frametime when user clicks off the window
                elapsedSec = ((nowMs - thenMs)/msPerSec) % frameTimeSecCap;
                thenMs = nowMs;

                for(const obj of objects) {
                    obj.update(elapsedSec);
                }
                
                render();
            }

            start();
        </script>
    </body>
</html>
